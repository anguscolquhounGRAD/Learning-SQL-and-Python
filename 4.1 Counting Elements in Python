##### 4.1 Counting Elements ######

#A numerical sequence can be stored in an array in various ways
#Standard appraoch a_0 , a_1, ..., a_n-1 are usually put in the the corrosponding index of array:
# A[0] = a_0  A[1] = a_1 .. A[n-1] = a_n-1

#We can make an array of counters. Suppose we have the numbers  0, 0 , 4, 2, 4, 5
#How many 0's do we have? 2. , How many 1's? 0. How many 2's? 1. and so on. 
#So we effectively have an array that looks like 2,0,1,0,2,1 , imagine the number underneath it.
#Under the 2 we have 0, since we have 2 0s. Under the 0 we have 1, because we have no 1s. 
#Under the 1 we have 2, since we only have one, 'two' in 0,0,4,2,4,5


#Counting Elements - O(n+m)

def counting(A, m):        # m is the maximum possible value in the array A
    n = len(A)
    count = [0] * (m + 1)
    for k in range(n):
        count[A[K]] += 1
    return count

# Suppose array A = [1,3,7] . Create an array of 0s of size 7 + 1
#            count =  [0,0,0,0,0,0,0,0]
#the index of count    0,1,2,3,4,5,6,7

# First iteration of k is 0, so we are refering to A[0] which is 1 (the 1st zero of array)
# So we add 1 into count, which makes it [0,1,0,0,0,0,0,0] .  
# REMEMBER BECAUSE WE ARE NOW DOING count[3] it references position 3 in the 0,0,0,0,0,0,0,0.
# The code then says to add and assign 1 to position 3! 


m = 
A = [a_0, a_1, a_2,...,a_n-1]
    #0     #1   #2       
B = [b_0, b_1, b_2,...,b_n-1]
      #0   #1   #2 ... 

